1. Abstract
   1.1 Concurrent bugs from open source applications(MySQL, Apache, Mozilla, OpenOffice)
   1.2 Findings:
       1.2.1 1/3 of nondeadlocks are caused by violation of programmers order intentions
       1.2.2 34% of nondeadlocks involve multiple variables
       1.2.3 Testing of concurrent programms can be focused on small number of memory accesses
       1.2.4 73% are hard fixes (difficult reasoning)
2. Introduction
   2.1 Concurrency bug detection:
       2.1.1 Data race bugs and deadlock bugs
       2.1.2 Questions:
       	     2.1.2.1 can existing tools detect all real-world concurrent bugs
	     2.1.2.2 how helpful are existing tools of diagnosing?
   2.2 Concurrent program testing and model checking
       2.2.1 Can we selectively test a small number of representative interleavings
       ans still expose most of the concurrency bugs?
       2.2.2 Manifestation conditions: how many threads, variables, how many accesses
       2.2.3 Concurrent programming language design:
       	     2.2.3.1 What portion of bugs can be avoided using TM?
	     2.2.3.2 What are the real world concerns that TM design needs to pay attention to?
	     2.2.3.3 What other programming languages supports besides TM?
       2.2.4 lack of a good real-world conc. bug characteristic study:
       	     2.2.4.1 It is difficult to collect real-world concurrency bugs
	     2.2.4.2 Concurrency bugs are not easy to understand
   2.3 Contributions
       2.3.1 First real-world concurrency study
       2.3.2 Examine: bug patterns, manifestations, fix strategies
3. Methodology
   3.1 Bug sources
       3.1.1 MySQL, Apache, Mozilla, OpenOffice
       3.1.2 Bugs:
       	     3.1.2.1 Keywords: "race(s)", "deadlock(s)", "synchronization(s)",
	     "concurrency", "lock(s)", "mutex(es)", "atomic", "compete(s)"
       3.1.3 Characteristic categories
       	     3.1.3.1 bug pattern
	     	    3.1.3.1.1 non-deadlock concurrency: atomicity-violation bugs, order-violation bugs, other
		     
	     3.1.3.2 manifestation
	     	    3.1.3.2.1 study the required condition
             3.1.3.3 final patch fix strategy
       3.1.4 threats to validity
       	     3.1.4.1 4 server and client-based concurrent applications written in C/C++
4. Bug pattern study
   4.1 Finding 1:
       4.1.1  Most (72 out of 74) of the examined non-deadlock concurrency bugs are covered by two simple
       patterns: atomicity violation and order violation
       4.1.2 Concurrent program bug detection, testing and language design should first focus on these two
       major bug patterns
   4.2 Finding 2:
       4.2.1 A significant number (24 out of 74) of the examined non-deadlock concurrency bugs are order bugs,
       which are not addressed by prvious bug detection work
       4.2.2 New bug detection techniques are desired to address order bugs
5. Bug manifestation study:
   5.1 How many threads are involved:
       5.1.1 Finding 3:
       	     5.1.1.1 The manifestation of most (101 out of 105) examined concurrency bugs involves no more than two threads
       5.1.2 Finding 4:
       	     5.2.1 The manifestation of some (7 out of 31) deadlock concurrency bugs involves only one thread
       	     5.2.2 This type of bug is relatively easy to detect and avoid. Bug detection and programming language techniques
       	     can try to eliminate these simple bugs first
   5.2 How many variables are involved:
       5.2.1 Finding 5:
       	     5.2.1.1 66% (49 out of 74) of the examined non-deadlock concurrency bugs involve only one variable
	     5.2.1.2 Focusing on cuncurrent accesses to one variable is a good simplification for concurrency bug detection
       5.2.2 Finding 6:
       	     5.2.2.1 A non-negligible number (34%) of non-deadlock concurrency bugs involve more than one variable
	     5.2.2.2 We need new concurrency bug detection tools to address mutiple variables concurrency bugs
       5.2.3 Finding 7:
       	     5.2.3.1 97% (30 out of 31) of the examined deadlock concurrency bugs involve at most two resources
	     5.2.3.2 Deadlock-oriented concurrent program testing can pairwise test the order among acquisition
	     and release of two resources
   5.3 How many accesses are involved?
       5.3.1 Finding 8:
       	     5.3.1.1 Finding 8.1: 90 % (67 out of 74) of the examined non-deadlock bugs can deterministically manifest,
	     if certain orders among at most four memory accesses are enforced
       	     5.3.1.2 Finding 8.2: 97% (30 out of 31) of the examined non-deadlock bugs can deterministically manifest,
	     if certain orders among at most four resource acquisition/release operations are enforced
	     5.3.1.3 Concurrent program testing can focus on the partial order among every small groups of accesses.
	     This simplifies the interleaving testing space from exponential to polynomial regarding to the total
	     number of accesses, with little loss of bug exposing capability
6. Bug fix study
   6.1 Finding 9:
       6.1.1 Adding or changing locks is not the major fix strategy. It is used for only 20 out of 74 non-deadlock
       concurrency bugs that we examined.
       6.1.2 There is no silver bullet for fixing concurrency bugs. Just telling programmers that certain conflicting
       accesses are not protected by the same lock is not enough to fix concurrency bugs
       6.1.3 Locks cannot enforce orders
       6.1.4 Locks can affect performance or introduce new bugs
   6.2 Condition check:
       6.2.1 while-flag to fix order related bug (better performance)
       6.2.2 Code switch: switching the order of certain code statements
   6.3 Algorithm/Data-structure design change:
       
       
       
       
   


	     